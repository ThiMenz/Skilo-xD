using System.Collections.Immutable;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics;

static class TrAI
{
    private static void Main(string[] args)
    {
        Trido trido = new Trido();
    }
}

class Trido
{
    //Predefined Consts / Values
    private const float heigth = 15, width = 29;
    private List<int[]> cardTypeBoundings = new List<int[]>() { new int[] { 0, 4 }, new int[] { 4, 8 }, new int[] { 8, 12 } };
    private List<Card> cards = new List<Card>() {
        new Card() { CardID = 0,  TypeID = 0, Name = "Horizontal Attack" },
        new Card() { CardID = 1,  TypeID = 0, Name = "Vertical Attack" },
        new Card() { CardID = 2,  TypeID = 0, Name = "Throw" },
        new Card() { CardID = 3,  TypeID = 0, Name = "Jump" },
        new Card() { CardID = 4,  TypeID = 1, Name = "Move 1" },
        new Card() { CardID = 5,  TypeID = 1, Name = "Move 2" },
        new Card() { CardID = 6,  TypeID = 1, Name = "Move 2 no Swap" },
        new Card() { CardID = 7,  TypeID = 1, Name = "Move 3 vertical" },
        new Card() { CardID = 8,  TypeID = 2, Name = "Build" },
        new Card() { CardID = 9,  TypeID = 2, Name = "Destroy" },
        new Card() { CardID = 10, TypeID = 2, Name = "Shield" },
        new Card() { CardID = 11, TypeID = 2, Name = "Manipulate" }
    };

    //Setup
    private int round = 1, turn = 1;

    private List<int> setupBlockades = new List<int>() { 8, 10, 18, 19, 20, 21, 22, 23, 24, 32, 34 };
    private List<int> playerTeam1Spawns = new List<int>() { 0, 1, 9 }, playerTeam2Spawns = new List<int>() { 40, 41, 42 }, playerLives1Setups = new List<int>() { 2, 2, 2 }, playerLives2Setups = new List<int>() { 2, 2, 2 };

    //High Usage Runtime
    private List<Field> fields = new List<Field>();
    private List<List<Field>> fieldColumns = new List<List<Field>>();

    private List<Player> players = new List<Player>();
    private List<List<Player>> playerTeams = new List<List<Player>>();

    private List<List<Card>> playedCards = new List<List<Card>>();
    private List<List<List<int>>> cardOptions = new List<List<List<int>>>(); //[PLAYER][TYPE][CARD]
    private List<List<List<int>>> cardOptionsTurn1 = new List<List<List<int>>>();

    //Runtime
    private System.Random RANDOM = new System.Random();
    private List<List<int>> APMCS_Options = new List<List<int>>();
    private List<int[]> APMCS_KnownCardBoundaries = new List<int[]>();

    public Trido()
    {
        BoardSetup();
        DrawBoard();
        List<int[]> temporaryBoundaries = new List<int[]>();
        for (int i = 0; i < 19; i++)
        {
            temporaryBoundaries.Add(new int[] { 0, 1 });
        }
        ApproximatedPrincipaledMonteCargoSearch(temporaryBoundaries);
    }

    private void ApproximatedPrincipaledMonteCargoSearch(List<int[]> knownCardBoundaries)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        int whichsTurn = (round + turn) % 2;
        APMCS_KnownCardBoundaries = knownCardBoundaries;

        for (int i = 0; i < 400000; i++)
        {
            ClearAPMCSOptions();
            for (int t = 0; t < 18; t++) whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[t]);

            ClearAPMCSOptions();
            for (int t = 0; t < 4; t++) whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[18]);

            //Evaluate Board

            //BlockadeReset();
            //PlayerSetup();

            //Reset Board
        }

        stopwatch.Stop();


        Console.WriteLine("Der Prozess hat " + stopwatch.ElapsedMilliseconds + " Millisekunden benötigt ¯\\_(o)_/¯");
        DrawBoard();


        //APMCS_Options[whichsTurn].Remove(0);

        //18x PrincipaledRandomMove
        //Round Reset
        //4x PrincipaledRandomMove
    }

    private int[] larr = new int[12] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
    private void ClearAPMCSOptions()
    {
        APMCS_Options.Clear();
        APMCS_Options.Add(new List<int>(larr));
        APMCS_Options.Add(new List<int>(larr));
    }

    private int PrincipaledRandomMove(int whichTeamsTurn, int[] cardBoundaries)
    {
        PlayAction(APMCS_Options[whichTeamsTurn][RANDOM.Next(cardBoundaries[0], cardBoundaries[1])], whichTeamsTurn);
        return 1 - whichTeamsTurn;
    }

    //private  void PricipaledRandomMove(CardInfo cardInfo)
    //{
    //    int whichTeamsTurn = (turn + round) % 2;
    //    if (cardInfo.cardValue == -1)
    //    {
    //        if (cardInfo.typeValue == -1) cardInfo.typeValue = RANDOM.Next(0, 3);
    //        cardInfo.cardValue = RANDOM.Next(0, cardOptions[whichTeamsTurn][cardInfo.typeValue].Count);
    //    }
    //    PlayPrincipaledAction(cardOptions[whichTeamsTurn][cardInfo.typeValue][cardInfo.cardValue], whichTeamsTurn);
    //    cardOptions[whichTeamsTurn][cardInfo.typeValue].RemoveAt(cardInfo.cardValue);
    //}

    private void PlayAction(int cardID, int whichsTurn)
    {
        //APMCS_Options[whichsTurn].Remove(cardID);
        switch (cardID)
        {
            case 0:
                int playerIndex = RANDOM.Next(0, playerTeams[whichsTurn].Count);
                SwapMove(playerTeams[whichsTurn][playerIndex].PosFieldID, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].soroundedTiles[RANDOM.Next(0, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].soroundedTiles.Count)]);
                break;
        }
    }

    private void SwapMove(int field1, int field2)
    {
        Field.State tempState = fields[field2].FieldState;
        Player tempPlayer = players[fields[field2].player.ID];

        tempPlayer.PosFieldID = field1;
        fields[field1].player.PosFieldID = field2;

        fields[field2].FieldState = fields[field1].FieldState;
        fields[field2].player = players[fields[field1].player.ID];

        fields[field1].FieldState = tempState;
        fields[field1].player = tempPlayer;
    }

    private void IncreaseTurn()
    {

    }

    private void BoardSetup()
    {
        //---> Board Creation
        int amount = 3, IDer = 3;
        bool backWards = false;
        for (int column = 0; amount > 2; column++)
        {
            fieldColumns.Add(new List<Field>());
            for (int a = 0; a < amount; a++)
            {
                if (amount == 7) backWards = true;

                fields.Add(new Field() { Pos = new Field.Position() { x = column * 2 + 2, y = 8 - amount + a * 2 }, FieldState = Field.State.Normal, Column = column, Diagonal = IDer - a, ID = fields.Count, Heigth = a });
                fieldColumns[column].Add(fields[fields.Count - 1]);
            }

            if (backWards) amount--;
            else
            {
                amount++;
                IDer++;
            }
        }

        //---> Set Setup Blockades & Player Positions
        for (int i = 0; i < setupBlockades.Count; i++)
        {
            fields[setupBlockades[i]].FieldState = Field.State.Blocked;
        }
        playerTeams.Add(new List<Player>());
        playerTeams.Add(new List<Player>());
        PlayerSetup();

        //---> Process field enviroments
        for (int f = 0; f < fields.Count; f++)
        {
            if (fields[f].Heigth != 0) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth - 1].ID);
            if (fields[f].Heigth + 1 != fieldColumns[fields[f].Column].Count) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth + 1].ID);

            int currentFieldDiagonal = fields[f].Diagonal;
            for (int it = -1; it < 2; it += 2)
            {
                if (fields[f].Column + it == fieldColumns.Count || fields[f].Column + it == -1) continue;

                for (int c1 = 0; c1 < fieldColumns[fields[f].Column + it].Count; c1++)
                    if (fieldColumns[fields[f].Column + it][c1].Diagonal == currentFieldDiagonal || fieldColumns[fields[f].Column + it][c1].Diagonal == currentFieldDiagonal + it)
                        fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column + it][c1].ID);
            }
        }

        //---> Card Options (Sorting)
        playedCards.Add(new List<Card>());
        playedCards.Add(new List<Card>());

        for (int i = 0; i < 2; i++)
        {
            cardOptionsTurn1.Add(new List<List<int>>());
            cardOptions.Add(new List<List<int>>());
            for (int t = 0; t < 3; t++)
            {
                cardOptionsTurn1[i].Add(new List<int>());
                cardOptions[i].Add(new List<int>());
            }
            for (int c = 0; c < cards.Count; c++)
            {
                cardOptionsTurn1[i][cards[c].TypeID].Add(cards[c].CardID);
                cardOptions[i][cards[c].TypeID].Add(cards[c].CardID);
            }
        }
    }

    private void PlayerSetup()
    {
        players.Clear();
        players.Add(new Player() { Null = true });
        for (int i = 0; i < playerTeam1Spawns.Count; i++)
        {
            Player p = new Player() { Team = 0, PosFieldID = playerTeam1Spawns[i], Lives = playerLives1Setups[i], Null = false, ID = i + 1 };
            players.Add(p);
            playerTeams[0].Add(players[players.Count - 1]);
            fields[playerTeam1Spawns[i]].FieldState = Field.State.BluePlayer;
            fields[playerTeam2Spawns[i]].player = p;
        }
        for (int i = 0; i < playerTeam2Spawns.Count; i++)
        {
            Player p = new Player() { Team = 1, PosFieldID = playerTeam2Spawns[i], Lives = playerLives2Setups[i], Null = false, ID = playerTeam1Spawns.Count + i + 1 };
            players.Add(p);
            playerTeams[1].Add(players[players.Count - 1]);
            fields[playerTeam2Spawns[i]].FieldState = Field.State.GreenPlayer;
            fields[playerTeam2Spawns[i]].player = p;
        }
    }

    private void BlockadeReset()
    {
        int a = 0;
        for (int f = 0; a < setupBlockades.Count; f++)
        {
            if (fields[f].ID == setupBlockades[a]) { 
                fields[f].FieldState = Field.State.Blocked;
                a++;
                continue;
            }
            fields[f].FieldState = Field.State.Normal;
        }
    }

    private void DrawBoard()
    {
        Console_Write("   {ROUND - " + round + "} ", ConsoleColor.DarkGreen);
        Console_Write("{Turn - " + turn + "}", ConsoleColor.DarkGreen);
        for (int h = 0; h < heigth; h++)
        {
            for (int w = 0; w < width; w++)
            {
                int tempField = GetFieldByPosition(w, h);

                if (tempField == -1)
                {
                    Console.Write("  ");
                    continue;
                }

                if (fields[tempField].FieldState == Field.State.Normal) Console_Write("■■", ConsoleColor.White);
                else if (fields[tempField].FieldState == Field.State.Blocked) Console_Write("##", ConsoleColor.Magenta);
                else if (fields[tempField].FieldState == Field.State.BluePlayer) Console_Write("()", ConsoleColor.Blue);
                else if (fields[tempField].FieldState == Field.State.GreenPlayer) Console_Write("()", ConsoleColor.Green);
            }
            Console.WriteLine();
        }
    }

    private void Console_Write(string s, ConsoleColor cc)
    {
        Console.ForegroundColor = cc;
        Console.Write(s);
        Console.ResetColor();
    }

    private int GetFieldByPosition(int x, int y)
    {
        for (int i = 0; i < fields.Count; i++)
            if (fields[i].Pos.x == x && fields[i].Pos.y == y)
                return i;
        return -1;
    }

    //public struct CardInfo
    //{
    //    public int cardValue, typeValue; //0 = e.g. Blue
    //}
}

public class Card
{
    public string Name = "";
    public int CardID, TypeID;
}

public class Player
{
    public int PosFieldID, Lives, Team, ID;
    public bool Null = true;
}

public class Field
{
    public Position Pos;
    public State FieldState;
    public int Column, Diagonal, Heigth, ID;
    public Player player = new Player();
    public List<int> soroundedTiles = new List<int>();
    public enum State { Normal, Blocked, BluePlayer, GreenPlayer }

    public struct Position
    {
        public int x, y;
    }
}
