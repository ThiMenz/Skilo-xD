using System.Collections.Immutable;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics;

static class TrAI
{
    private static void Main(string[] args)
    {
        APMCS trido = new APMCS();
    }
}

#region TO-DO-APMCS

//THILOS IN-CODE TO-DO ->

//=> [FINISHED] Vertical Movement Null-Player Fix

//=> [FINISHED] Custom Reset with player lives = 0 handling

//=> [FINISHED] Increase Turn Method & Board Visualizing with player turn shower

//=> [FINISHED] General Tridon (Counter, Visuals, etc.)

//=> [FINISHED] Tridon Checks after any movements

//=> [FINISHED] Terminal State Handling

//-----------------------

//=> "Tiles over/under tile"-List for every field (for the vertical attack)

//=> "Jump Tiles"-List for every field

//=> Working throw logic (int[2] underAttk-Fields?)

//=> Manipulate (similar to Action1)

//=> Place / Destroy

//=> Shield (Just setting Player.ShieldUntilTurn value)

//-----------------------

//=> Methods Commentary (espacially completing summaries)

//=> Evaluation Function & Sums

//-----------------------

//=> Principals (ahh)

//=> I/O (Input options + Output of resulting card)

#endregion

class APMCS
{
    #region VARIABLES

    //Predefined Consts / Values
    private const float heigth = 15, width = 29;
    private List<int[]> cardTypeBoundings = new List<int[]>() { new int[] { 0, 4 }, new int[] { 4, 8 }, new int[] { 8, 12 } };
    private List<Card> cards = new List<Card>() {
        new Card() { CardID = 0,  TypeID = 0, Name = "Horizontal Attack" },
        new Card() { CardID = 1,  TypeID = 0, Name = "Vertical Attack" },
        new Card() { CardID = 2,  TypeID = 0, Name = "Throw" },
        new Card() { CardID = 3,  TypeID = 0, Name = "Jump" },
        new Card() { CardID = 4,  TypeID = 1, Name = "Move 1" },
        new Card() { CardID = 5,  TypeID = 1, Name = "Move 2" },
        new Card() { CardID = 6,  TypeID = 1, Name = "Move 2 no Swap" },
        new Card() { CardID = 7,  TypeID = 1, Name = "Move 3 vertical" },
        new Card() { CardID = 8,  TypeID = 2, Name = "Build" },
        new Card() { CardID = 9,  TypeID = 2, Name = "Destroy" },
        new Card() { CardID = 10, TypeID = 2, Name = "Shield" },
        new Card() { CardID = 11, TypeID = 2, Name = "Manipulate" }
    };

    //Setup SHIELD IS MISSING
    private int round = 1, turn = 19;

    private List<int> setupBlockades = new List<int>() { 10, 18, 19, 22, 23, 24, 32, 34 };
    private List<int> playerTeam1Spawns = new List<int>() { 0, 1, 13 }, playerTeam2Spawns = new List<int>() { 12, 8, 20 }, playerLives1Setups = new List<int>() { 2, 2, 2 }, playerLives2Setups = new List<int>() { 2, 2, 2 };
    private int[] collectedTridons = new int[2] { 0, 0 };
    private bool isTridonOnBoard = true;

    private int playerSpawnCount; //Including null-Player
    private List<int> playerSpawns = new List<int>();

    //High Usage Runtime
    private List<Field> fields = new List<Field>();
    private List<List<Field>> fieldColumns = new List<List<Field>>();

    private List<Player> players = new List<Player>();
    private List<Player> playersCopy = new List<Player>();
    private List<List<Player>> playerTeams = new List<List<Player>>();

    private List<List<Card>> playedCards = new List<List<Card>>();
    private List<List<List<int>>> cardOptions = new List<List<List<int>>>(); //[PLAYER][TYPE][CARD]
    private List<List<List<int>>> cardOptionsTurn1 = new List<List<List<int>>>();

    //Runtime
    private System.Random RANDOM = new System.Random();

    private bool Simulation_Terminal_State = false;
    private int[] Simulation_Player_Count = new int[2];

    private List<List<int>> APMCS_Options = new List<List<int>>();
    private List<int[]> APMCS_KnownCardBoundaries = new List<int[]>();

    private int[] larr = new int[12] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
    private int[] larr2 = new int[2] { -1, 1 };

    #endregion

    #region MAIN

    /// <summary>
    /// 
    /// </summary>
    public APMCS()
    {
        BoardSetup();
        List<int[]> temporaryBoundaries = new List<int[]>();
        for (int i = 0; i < 19; i++)
        {
            temporaryBoundaries.Add(new int[] { 0, 2 });
        }
        ApproximatedPrincipaledMonteCargoSearch(temporaryBoundaries);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="knownCardBoundaries">An list of arrays which is showing the known limitations for the played cards</param>
    private void ApproximatedPrincipaledMonteCargoSearch(List<int[]> knownCardBoundaries)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        //Pre Calculations & Saves
        int whichsTurn = (round + turn) % 2;
        int whichsTurnCopy = whichsTurn;
        int roundCopy = round;
        int turnCopy = turn;
        bool tridonCopy = isTridonOnBoard;
        int[] tridonsCounterCopy = new int[2] { collectedTridons[0], collectedTridons[1] };
        APMCS_KnownCardBoundaries = knownCardBoundaries;

        //Board evaluations count
        for (int i = 0; i < 400000; i++)
        {
            //Current Round Turn Rolling (Full Round)
            ClearAPMCSOptions();
            for (int t = 0; t < 18; t++)
            {
                if (Simulation_Terminal_State) goto RollOutEnd;
                //DrawBoard();
                turn++;
                whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[t]);
            }

            //Following Round Turn Rolling (Portion of Round)
            turn = 1;
            round++;
            whichsTurn = 1 - whichsTurn;
            ClearAPMCSOptions();
            for (int t = 0; t < 4; t++)
            {
                if (Simulation_Terminal_State) goto RollOutEnd;
                //DrawBoard();
                turn++;
                whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[18]);
            }

            //End of Roll Out Iteration
        RollOutEnd:
            //Evaluate Board


            //Reset Board
            Simulation_Terminal_State = false;
            whichsTurn = whichsTurnCopy;
            round = roundCopy;
            turn = turnCopy;
            collectedTridons[0] = tridonsCounterCopy[0];
            collectedTridons[1] = tridonsCounterCopy[1];
            isTridonOnBoard = tridonCopy;
            PlayerReset();
            BlockadeReset();
        }

        stopwatch.Stop();

        DrawBoard();
        Console.WriteLine("Der Prozess hat " + stopwatch.ElapsedMilliseconds + " Millisekunden benötigt ¯\\_(o)_/¯");
    }

    /// <summary>
    /// Plays one rollout move from the APMCS
    /// </summary>
    /// <param name="whichTeamsTurn">0 = Blue / 1 = Green</param>
    /// <param name="cardBoundaries">An array which includes the lowest and highest possible card index</param>
    /// <returns></returns>
    private int PrincipaledRandomMove(int whichTeamsTurn, int[] cardBoundaries)
    {
        PlayRandomAction(APMCS_Options[whichTeamsTurn][RANDOM.Next(cardBoundaries[0], cardBoundaries[1])], whichTeamsTurn);

        isTridonOnBoard = isTridonOnBoard && fields[21].FieldState == Field.State.Normal;
            
        return 1 - whichTeamsTurn;
    }


    /// <summary>
    /// 
    /// </summary>
    private int EvaluateBoard()
    {


        return 0;
    }

    #endregion

    #region ACTIONS

    /// <summary>
    /// Plays a random action including changing all needed board values for that specific action.
    /// </summary>
    /// <param name="cardID">The ID of the played card</param>
    /// <param name="whichsTurn"></param>
    private void PlayRandomAction(int cardID, int whichsTurn)
    {
        //APMCS_Options[whichsTurn].Remove(cardID);
        switch (cardID)
        {
            //MOVEMENT
            case 0: Action2(whichsTurn); break; //Move-1-Swap

            case 1: Action4(whichsTurn); break; //Move-2-Non-Swap

            case 2: Action2(whichsTurn); break; //Move-2-Swap

            case 3: Action3(whichsTurn); break; //Move-3-Vertically

            //ATTACKS
            case 4: Action4(whichsTurn); break; // Horizontal Attack
        }
    }

    //All Action Methods ->
    //P -> Performance Value (higher = slower) -> UPDATE?

    private void Action0(int whichsTurn)
    {
        int playerIndex = PickRandomPlayer(whichsTurn);
        int tempPlayerFieldID = players[playerIndex].PosFieldID;
        SwapMove(tempPlayerFieldID, fields[tempPlayerFieldID].soroundedTiles[RANDOM.Next(0, fields[tempPlayerFieldID].soroundedTiles.Count)]);
    }
    private void Action1(int whichsTurn) //Really rare simulations which are not possible due to completely random player picks (Fix?)
    {
        int playerIndex = PickRandomPlayer(whichsTurn);
        int tempPlayerFieldID = players[playerIndex].PosFieldID;
        UpdateFieldTempSorouToEmpty(tempPlayerFieldID);
        if (fields[tempPlayerFieldID].tempTiles.Count != 0)
        {
            int tempRandomField = fields[tempPlayerFieldID].tempTiles[RANDOM.Next(0, fields[tempPlayerFieldID].tempTiles.Count)];
            UpdateFieldTempSorouToEmpty(tempRandomField);
            fields[tempRandomField].tempTiles.Add(tempPlayerFieldID);
            NonSwapMove(tempPlayerFieldID, fields[tempRandomField].tempTiles[RANDOM.Next(0, fields[tempRandomField].tempTiles.Count)]);
        }
    }
    private void Action2(int whichsTurn) 
    {
        int playerIndex = PickRandomPlayer(whichsTurn);
        int tempPlayerFieldID = players[playerIndex].PosFieldID;
        int tempSubPlayerPos = fields[tempPlayerFieldID].soroundedTiles[RANDOM.Next(0, fields[tempPlayerFieldID].soroundedTiles.Count)];
        SwapMove(tempPlayerFieldID, tempSubPlayerPos);
        SwapMove(tempSubPlayerPos, fields[tempSubPlayerPos].soroundedTiles[RANDOM.Next(0, fields[tempSubPlayerPos].soroundedTiles.Count)]);
    }
    private void Action3(int whichsTurn)
    {
        int playerCount = playerTeams[whichsTurn].Count;
        int a = 0;
        for (int p = RANDOM.Next(0, playerCount); a < playerCount; p++)
        {
            int tempField = playerTeams[whichsTurn][p].PosFieldID;
            if (!playerTeams[whichsTurn][p].Null && HasFieldVerticalMovementOptions(tempField))
            {
                for (int i = 0; i < 3; i++)
                {
                    int random = RANDOM.Next(0, fields[tempField].verticalSorou.Count);
                    if (fields[fields[tempField].verticalSorou[random]].FieldState != Field.State.Normal) random = 1 - random;
                    NonSwapMove(tempField, fields[tempField].verticalSorou[random]);
                    tempField = fields[tempField].verticalSorou[random];
                }
                break;
            }
            a++;
            if (p == playerCount - 1) p = -1;
        }
    }
    private void Action4(int whichsTurn)
    {
        int playerPos = players[PickRandomPlayer(whichsTurn)].PosFieldID;
        
        for (int i = fields[playerPos].horizontalAttackSorou.Count-1; i > -1; i--)
            DamagePlayer(fields[fields[playerPos].horizontalAttackSorou[i]].PlayerID, whichsTurn);
    }

    #endregion

    #region ACTION HANDLING

    /// <summary>
    /// 
    /// </summary>
    /// <param name="playerID"></param>
    /// <param name="immuneTeam"></param>
    private void DamagePlayer(int playerID, int immuneTeam)
    {
        if (players[playerID].Team == immuneTeam) return;
        if (players[playerID].Null) return;
        if (turn <= players[playerID].ShieldUntilTurn) return;
        if (--players[playerID].Lives == 0)
        {
            players[playerID].Null = true;
            int tempPlayerPos = players[playerID].PosFieldID;
            fields[tempPlayerPos].PlayerID = 0;
            fields[tempPlayerPos].FieldState = Field.State.Normal;
            if (--Simulation_Player_Count[players[playerID].Team] == 0) Simulation_Terminal_State = true;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="whichsTurn"></param>
    /// <returns></returns>
    private int PickRandomPlayer(int whichsTurn)
    {
        int count = playerTeams[whichsTurn].Count;
        int random = RANDOM.Next(0, count);
        while(true) { 
            if (!playerTeams[whichsTurn][random].Null) return playerTeams[whichsTurn][random].ID;

            if (++random == count) random = 0;
        }
    }

    /// <summary>
    /// Swaps the (player)-state between these two fields. 
    /// </summary>
    /// <param name="field1">Index of field 1</param>
    /// <param name="field2">Index of field 2</param>
    private void SwapMove(int field1, int field2)
    {
        Field.State tempState = fields[field2].FieldState;
        int tempPlayer = fields[field2].PlayerID;

        players[fields[field1].PlayerID].PosFieldID = field2;
        fields[field2].FieldState = fields[field1].FieldState;
        fields[field2].PlayerID = fields[field1].PlayerID;

        players[tempPlayer].PosFieldID = field1;
        fields[field1].FieldState = tempState;
        fields[field1].PlayerID = tempPlayer;

        TridonCheck();
    }

    /// <summary>
    /// Swaps the states of the fields between these two fields and sets the position of the player to the endfield.
    /// </summary>
    /// <param name="startField">The field on which the player is standing</param>
    /// <param name="endField">The field on which the player should go</param>
    private void NonSwapMove(int startField, int endField)
    {
        if (startField == endField) return; //(nur nötig, wenn man auch den Case haben kann -> wie bei Action 1)

        players[fields[startField].PlayerID].PosFieldID = endField;
        fields[endField].FieldState = fields[startField].FieldState;
        fields[endField].PlayerID = fields[startField].PlayerID;
        fields[startField].FieldState = Field.State.Normal;
        fields[startField].PlayerID = 0;

        TridonCheck();
    }

    /// <summary>
    /// 
    /// </summary>
    private void TridonCheck()
    {
        if (players[fields[21].PlayerID].Null) return;

        isTridonOnBoard = false;
        if (++collectedTridons[players[fields[21].PlayerID].Team] == 3) Simulation_Terminal_State = true;
    }

    #endregion

    #region BOARD MANAGEMENT

    /// <summary>
    /// Adds all normal stated ("empty") adjacent fields to the tempList of the specific field.
    /// </summary>
    /// <param name="field">The field which should get processed</param>
    private void UpdateFieldTempSorouToEmpty(int field)
    {
        fields[field].tempTiles.Clear();
        for (int f = 0; f < fields[field].soroundedTiles.Count; f++)
            if (fields[fields[field].soroundedTiles[f]].FieldState == Field.State.Normal)
                fields[field].tempTiles.Add(fields[field].soroundedTiles[f]);
    }

    /// <summary>
    /// Sets the players back to their spawn position.
    /// </summary>
    private void PlayerReset()
    {
        Simulation_Player_Count[0] = playerTeam1Spawns.Count;
        Simulation_Player_Count[1] = playerTeam2Spawns.Count;

        for (int i = 1; i < players.Count; i++)
        {
            fields[players[i].PosFieldID].FieldState = Field.State.Normal;
            fields[players[i].PosFieldID].PlayerID = 0;
        }

        for (int i = 1; i < players.Count; i++)
        {
            players[i].Null = false;
            players[i].Lives = playersCopy[i].Lives;
            players[i].ShieldUntilTurn = playersCopy[i].ShieldUntilTurn;
            players[i].PosFieldID = playerSpawns[i];
            fields[playerSpawns[i]].PlayerID = i;
            fields[playerSpawns[i]].FieldState = (players[i].Team == 0 ? Field.State.BluePlayer : Field.State.GreenPlayer);
        }
    }

    /// <summary> 
    /// Loads the firstly spawned blockade positions back.
    /// </summary>
    private void BlockadeReset()
    {
        for (int f = 0; f < fields.Count; f++)
        {
            if (fields[f].FieldState == Field.State.Blocked)
                fields[f].FieldState = Field.State.Normal;
        }

        for (int i = 0; i < setupBlockades.Count; i++)
            fields[setupBlockades[i]].FieldState = Field.State.Blocked;
    }

    /// <summary>
    /// Loads the fields, as well as the spawn positions of the players and the blockades, calculates the sourounding fields and pre calculates possible card options.
    /// </summary>
    private void BoardSetup()
    {
        //---> Board Creation
        int amount = 3, IDer = 3;
        bool backWards = false;
        for (int column = 0; amount > 2; column++)
        {
            fieldColumns.Add(new List<Field>());
            for (int a = 0; a < amount; a++)
            {
                if (amount == 7) backWards = true;

                fields.Add(new Field() { Pos = new Field.Position() { x = column * 2 + 2, y = 8 - amount + a * 2 }, FieldState = Field.State.Normal, Column = column, Diagonal = IDer - a, ID = fields.Count, Heigth = a });
                fieldColumns[column].Add(fields[fields.Count - 1]);
            }

            if (backWards) amount--;
            else
            {
                amount++;
                IDer++;
            }
        }

        //---> Set Setup Blockades & Player Positions
        for (int i = 0; i < setupBlockades.Count; i++)
        {
            fields[setupBlockades[i]].FieldState = Field.State.Blocked;
        }
        playerTeams.Add(new List<Player>());
        playerTeams.Add(new List<Player>());
        players.Add(new Player() { Null = true });
        playerSpawns.Add(-1);
        for (int i = 0; i < playerTeam1Spawns.Count; i++)
        {
            Player p = new Player() { Team = 0, PosFieldID = playerTeam1Spawns[i], Lives = playerLives1Setups[i], Null = false, ID = i + 1 };
            players.Add(p);
            playerTeams[0].Add(players[players.Count - 1]);
            fields[playerTeam1Spawns[i]].FieldState = Field.State.BluePlayer;
            fields[playerTeam1Spawns[i]].PlayerID = players.Count - 1;
            playerSpawns.Add(playerTeam1Spawns[i]);
        }
        for (int i = 0; i < playerTeam2Spawns.Count; i++)
        {
            Player p = new Player() { Team = 1, PosFieldID = playerTeam2Spawns[i], Lives = playerLives2Setups[i], Null = false, ID = playerTeam1Spawns.Count + i + 1 };
            players.Add(p);
            playerTeams[1].Add(players[players.Count - 1]);
            fields[playerTeam2Spawns[i]].FieldState = Field.State.GreenPlayer;
            fields[playerTeam2Spawns[i]].PlayerID = players.Count - 1;
            playerSpawns.Add(playerTeam2Spawns[i]);
        }
        playerSpawnCount = playerTeam1Spawns.Count + playerTeam2Spawns.Count + 1;

        for (int i = 0; i < players.Count; i++)
        {
            playersCopy.Add(new Player() { Team = players[i].Team, PosFieldID = players[i].PosFieldID, Lives = players[i].Lives, Null = players[i].Null, ID = players[i].ID });
        }

        //---> Process field enviroments
        for (int f = 0; f < fields.Count; f++)
        {
            if (fields[f].Heigth != 0) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth - 1].ID);
            if (fields[f].Heigth + 1 != fieldColumns[fields[f].Column].Count) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth + 1].ID);

            int currentFieldDiagonal = fields[f].Diagonal;
            for (int it = -1; it < 2; it += 2)
            {
                int cColumn = fields[f].Column;

                if (cColumn + it == fieldColumns.Count || cColumn + it == -1) continue;

                for (int c1 = 0; c1 < fieldColumns[cColumn + it].Count; c1++)
                {
                    if (fieldColumns[cColumn + it][c1].Diagonal == currentFieldDiagonal || fieldColumns[cColumn + it][c1].Diagonal == currentFieldDiagonal + it)
                    {
                        fields[f].soroundedTiles.Add(fieldColumns[cColumn + it][c1].ID);
                        fields[f].horizontalAttackSorou.Add(fieldColumns[cColumn + it][c1].ID);
                    }
                }

                if (cColumn + it * 2 == fieldColumns.Count || cColumn + it * 2 == -1) continue;

                for (int c1 = 0; c1 < fieldColumns[cColumn + it * 2].Count; c1++)
                {
                    if (fieldColumns[cColumn + it * 2][c1].Diagonal == fields[f].Diagonal + it) {
                        fields[f].horizontalAttackSorou.Add(fieldColumns[cColumn + it * 2][c1].ID);
                        break;
                    }
                }
            }

            int tempHeigth = fields[f].Heigth;
            if (tempHeigth > 0 && f != 0) fields[f].verticalSorou.Add(fields[f].ID - 1);
            if (tempHeigth + 1 < fieldColumns[fields[f].Column].Count) fields[f].verticalSorou.Add(fields[f].ID + 1);
        }

        //---> Card Options (Sorting) [Currently not used!]
        playedCards.Add(new List<Card>());
        playedCards.Add(new List<Card>());

        for (int i = 0; i < 2; i++)
        {
            cardOptionsTurn1.Add(new List<List<int>>());
            cardOptions.Add(new List<List<int>>());
            for (int t = 0; t < 3; t++)
            {
                cardOptionsTurn1[i].Add(new List<int>());
                cardOptions[i].Add(new List<int>());
            }
            for (int c = 0; c < cards.Count; c++)
            {
                cardOptionsTurn1[i][cards[c].TypeID].Add(cards[c].CardID);
                cardOptions[i][cards[c].TypeID].Add(cards[c].CardID);
            }
        }
    }

    #endregion

    #region VISUALS

    /// <summary>
    /// Visualizes a board position by drawing it specifically in the Console.
    /// </summary>
    private void DrawBoard()
    {
        var tempConsoleColor = ConsoleColor.Green;
        if ((round + turn) % 2 == 0) tempConsoleColor = ConsoleColor.Blue;
        Console_Write(" (" + collectedTridons[0].ToString() + ")", ConsoleColor.Blue);
        Console_Write("     {ROUND - " + round + "} ", tempConsoleColor);
        Console_Write(" {Turn - " + turn + "}     ", tempConsoleColor);
        Console_Write("(" + collectedTridons[0].ToString() + ")", ConsoleColor.Green);
        for (int h = 0; h < heigth; h++)
        {
            for (int w = 0; w < width; w++)
            {
                int tempField = GetFieldByPosition(w, h);

                if (tempField == -1)
                {
                    Console.Write("  ");
                    continue;
                }

                if(tempField == 21 && isTridonOnBoard)
                {
                    Console_Write("()", ConsoleColor.Yellow);
                    continue;
                }

                if (fields[tempField].FieldState == Field.State.Normal) Console_Write("■■", ConsoleColor.White);
                else if (fields[tempField].FieldState == Field.State.Blocked) Console_Write("##", ConsoleColor.Magenta);
                else if (fields[tempField].FieldState == Field.State.BluePlayer)
                {
                    //players[fields[tempField].playerID].Lives 
                    Console_Write((players[fields[tempField].PlayerID].Lives == 2) ? "[]" : "{}", ConsoleColor.Blue);
                }
                else if (fields[tempField].FieldState == Field.State.GreenPlayer)
                {
                    Console_Write((players[fields[tempField].PlayerID].Lives == 2) ? "[]" : "{}", ConsoleColor.Green);
                }
            }
            Console.WriteLine();
        }
    }

    #endregion

    #region UTILITY

    /// <summary>
    /// Writes a text to the console in a specific color.
    /// </summary>
    /// <param name="s">The text content</param>
    /// <param name="cc">The text color</param>
    private void Console_Write(string s, ConsoleColor cc)
    {
        Console.ForegroundColor = cc;
        Console.Write(s);
        Console.ResetColor();
    }

    /// <summary>
    /// Tries to find a field out of the fields-array with a specific visual position. Returns the fields-index or -1 if the position doesn't exist.
    /// </summary>
    /// <param name="x">The X-Position</param>
    /// <param name="y">The Y-Position</param>
    /// <returns></returns>
    private int GetFieldByPosition(int x, int y)
    {
        for (int i = 0; i < fields.Count; i++)
            if (fields[i].Pos.x == x && fields[i].Pos.y == y)
                return i;
        return -1;
    }


    /// <summary>
    /// Gives both players all card options back (2x Lists from 0-11)
    /// </summary>
    private void ClearAPMCSOptions()
    {
        APMCS_Options.Clear();
        APMCS_Options.Add(new List<int>(larr));
        APMCS_Options.Add(new List<int>(larr));
    }

    /// <summary>
    /// Checks if a player on the specific field could execute a vertical movement there.
    /// </summary>
    /// <param name="field">The field on which the player is standing</param>
    /// <returns></returns>
    private bool HasFieldVerticalMovementOptions(int field)
    {
        if (fields[fields[field].verticalSorou[0]].FieldState == Field.State.Normal) return true;
        if (fields[field].verticalSorou.Count == 1) return false;
        if (fields[fields[field].verticalSorou[1]].FieldState == Field.State.Normal) return true;
        return false;
    }

    #endregion
}

#region DATA CLASSES

public class Card
{
    public string Name = "";
    public int CardID, TypeID;
}

public class Player
{
    public int PosFieldID, Lives, Team, ID, ShieldUntilTurn;
    public bool Null = true;
}

public class Field
{
    public Position Pos;
    public State FieldState;
    public int Column, Diagonal, Heigth, ID, PlayerID;
    public List<int> soroundedTiles = new List<int>(), tempTiles = new List<int>(), verticalSorou = new List<int>(), horizontalAttackSorou = new List<int>();
    public enum State { Normal, Blocked, BluePlayer, GreenPlayer }

    public struct Position
    {
        public int x, y;
    }
}

#endregion
