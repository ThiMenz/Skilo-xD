using System.Collections.Immutable;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics;

static class TrAI
{
    private static void Main(string[] args)
    {
        APMCS trido = new APMCS();
    }
}

class APMCS
{
    #region VARIABLES

    //Predefined Consts / Values
    private const float heigth = 15, width = 29;
    private List<int[]> cardTypeBoundings = new List<int[]>() { new int[] { 0, 4 }, new int[] { 4, 8 }, new int[] { 8, 12 } };
    private List<Card> cards = new List<Card>() {
        new Card() { CardID = 0,  TypeID = 0, Name = "Horizontal Attack" },
        new Card() { CardID = 1,  TypeID = 0, Name = "Vertical Attack" },
        new Card() { CardID = 2,  TypeID = 0, Name = "Throw" },
        new Card() { CardID = 3,  TypeID = 0, Name = "Jump" },
        new Card() { CardID = 4,  TypeID = 1, Name = "Move 1" },
        new Card() { CardID = 5,  TypeID = 1, Name = "Move 2" },
        new Card() { CardID = 6,  TypeID = 1, Name = "Move 2 no Swap" },
        new Card() { CardID = 7,  TypeID = 1, Name = "Move 3 vertical" },
        new Card() { CardID = 8,  TypeID = 2, Name = "Build" },
        new Card() { CardID = 9,  TypeID = 2, Name = "Destroy" },
        new Card() { CardID = 10, TypeID = 2, Name = "Shield" },
        new Card() { CardID = 11, TypeID = 2, Name = "Manipulate" }
    };

    //Setup
    private int round = 1, turn = 1;

    private List<int> setupBlockades = new List<int>() { 8, 10, 18, 19, 20, 21, 22, 23, 24, 32, 34 };
    private List<int> playerTeam1Spawns = new List<int>() { 0, 1, 9 }, playerTeam2Spawns = new List<int>() { 40, 41, 42 }, playerLives1Setups = new List<int>() { 2, 2, 2 }, playerLives2Setups = new List<int>() { 2, 2, 2 };

    private int playerSpawnCount; //Including null-Player
    private List<int> playerSpawns = new List<int>();

    //High Usage Runtime
    private List<Field> fields = new List<Field>();
    private List<List<Field>> fieldColumns = new List<List<Field>>();

    private List<Player> players = new List<Player>();
    private List<List<Player>> playerTeams = new List<List<Player>>();

    private List<List<Card>> playedCards = new List<List<Card>>();
    private List<List<List<int>>> cardOptions = new List<List<List<int>>>(); //[PLAYER][TYPE][CARD]
    private List<List<List<int>>> cardOptionsTurn1 = new List<List<List<int>>>();

    //Runtime
    private System.Random RANDOM = new System.Random();

    private List<List<int>> APMCS_Options = new List<List<int>>();
    private List<int[]> APMCS_KnownCardBoundaries = new List<int[]>();

    private int[] larr = new int[12] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };

    #endregion

    #region MAIN

    /// <summary>
    /// 
    /// </summary>
    public APMCS()
    {
        BoardSetup();
        DrawBoard();
        List<int[]> temporaryBoundaries = new List<int[]>();
        for (int i = 0; i < 19; i++)
        {
            temporaryBoundaries.Add(new int[] { 1, 2 });
        }
        ApproximatedPrincipaledMonteCargoSearch(temporaryBoundaries);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="knownCardBoundaries">An list of arrays which is showing the known limitations for the played cards</param>
    private void ApproximatedPrincipaledMonteCargoSearch(List<int[]> knownCardBoundaries)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        //Pre Calculations
        int whichsTurn = (round + turn) % 2;
        APMCS_KnownCardBoundaries = knownCardBoundaries;

        //Board evaluations count
        for (int i = 0; i < 400000; i++)
        {
            //Current Round Turn Rolling (Full Round)
            ClearAPMCSOptions();
            for (int t = 0; t < 18; t++) whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[t]);

            //Following Round Turn Rolling (Portion of Round)
            ClearAPMCSOptions();
            for (int t = 0; t < 4; t++) whichsTurn = PrincipaledRandomMove(whichsTurn, APMCS_KnownCardBoundaries[18]);

            //Evaluate Board


            //Reset Board
            PlayerReset();
            BlockadeReset();
        }

        stopwatch.Stop();

        DrawBoard();
        Console.WriteLine("Der Prozess hat " + stopwatch.ElapsedMilliseconds + " Millisekunden benötigt ¯\\_(o)_/¯");
    }

    /// <summary>
    /// Plays one rollout move from the APMCS
    /// </summary>
    /// <param name="whichTeamsTurn">0 = Blue / 1 = Green</param>
    /// <param name="cardBoundaries">An array which includes the lowest and highest possible card index</param>
    /// <returns></returns>
    private int PrincipaledRandomMove(int whichTeamsTurn, int[] cardBoundaries)
    {
        PlayRandomAction(APMCS_Options[whichTeamsTurn][RANDOM.Next(cardBoundaries[0], cardBoundaries[1])], whichTeamsTurn);
        //DrawBoard();
        return 1 - whichTeamsTurn;
    }

    #endregion

    #region ACTIONS

    /// <summary>
    /// Plays a random action including changing all needed board values for that specific action.
    /// </summary>
    /// <param name="cardID">The ID of the played card</param>
    /// <param name="whichsTurn"></param>
    private void PlayRandomAction(int cardID, int whichsTurn)
    {
        //APMCS_Options[whichsTurn].Remove(cardID);
        int playerIndex = 0;
        switch (cardID)
        {
            case 0: //Move-1-Swap
                playerIndex = RANDOM.Next(0, playerTeams[whichsTurn].Count);
                SwapMove(playerTeams[whichsTurn][playerIndex].PosFieldID, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].soroundedTiles[RANDOM.Next(0, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].soroundedTiles.Count)]);
                break;

            case 1: //Move-2-Non-Swap
                playerIndex = RANDOM.Next(0, playerTeams[whichsTurn].Count);

                UpdateFieldTempSorouToEmpty(playerTeams[whichsTurn][playerIndex].PosFieldID);
                if (fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles.Count != 0) NonSwapMove(playerTeams[whichsTurn][playerIndex].PosFieldID, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles[RANDOM.Next(0, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles.Count)]);
                UpdateFieldTempSorouToEmpty(playerTeams[whichsTurn][playerIndex].PosFieldID);
                if (fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles.Count != 0) NonSwapMove(playerTeams[whichsTurn][playerIndex].PosFieldID, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles[RANDOM.Next(0, fields[playerTeams[whichsTurn][playerIndex].PosFieldID].tempTiles.Count)]);
                break;

            case 2:

                break;
        }
    }

    /// <summary>
    /// Swaps the (player)-state between these two fields. 
    /// </summary>
    /// <param name="field1">Index of field 1</param>
    /// <param name="field2">Index of field 2</param>
    private void SwapMove(int field1, int field2)
    {
        Field.State tempState = fields[field2].FieldState;
        int tempPlayer = fields[field2].PlayerID;

        players[fields[field1].PlayerID].PosFieldID = field2;
        fields[field2].FieldState = fields[field1].FieldState;
        fields[field2].PlayerID = fields[field1].PlayerID;

        players[tempPlayer].PosFieldID = field1;
        fields[field1].FieldState = tempState;
        fields[field1].PlayerID = tempPlayer;
    }

    private void NonSwapMove(int startField, int endField)
    {
        players[fields[startField].PlayerID].PosFieldID = endField;
        fields[endField].FieldState = fields[startField].FieldState;
        fields[endField].PlayerID = fields[startField].PlayerID;
        fields[startField].FieldState = Field.State.Normal;
        fields[startField].PlayerID = 0;
    }

    #endregion

    #region BOARD MANAGEMENT

    /// <summary>
    /// 
    /// </summary>
    private void UpdateFieldTempSorouToEmpty(int field)
    {
        fields[field].tempTiles.Clear();
        for (int f = 0; f < fields[field].soroundedTiles.Count; f++)
            if (fields[fields[field].soroundedTiles[f]].FieldState == Field.State.Normal)
                fields[field].tempTiles.Add(fields[field].soroundedTiles[f]);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    private int TerminalState()
    {


        return 0;
    }

    /// <summary>
    /// 
    /// </summary>
    private int EvaluateBoard()
    {


        return 0;
    }

    /// <summary>
    /// Sets the players back to their spawn position.
    /// </summary>
    private void PlayerReset()
    {
        for (int i = 1; i < players.Count; i++)
            SwapMove(players[i].PosFieldID, playerSpawns[i]);
    }

    /// <summary> 
    /// Loads the firstly spawned blockade positions back.
    /// </summary>
    private void BlockadeReset()
    {
        for (int f = 0; f < fields.Count; f++)
            if (fields[f].FieldState == Field.State.Blocked)
                fields[f].FieldState = Field.State.Normal;

        for (int i = 0; i < setupBlockades.Count; i++)
            fields[setupBlockades[i]].FieldState = Field.State.Blocked;
    }

    /// <summary>
    /// Loads the fields, as well as the spawn positions of the players and the blockades, calculates the sourounding fields and pre calculates possible card options.
    /// </summary>
    private void BoardSetup()
    {
        //---> Board Creation
        int amount = 3, IDer = 3;
        bool backWards = false;
        for (int column = 0; amount > 2; column++)
        {
            fieldColumns.Add(new List<Field>());
            for (int a = 0; a < amount; a++)
            {
                if (amount == 7) backWards = true;

                fields.Add(new Field() { Pos = new Field.Position() { x = column * 2 + 2, y = 8 - amount + a * 2 }, FieldState = Field.State.Normal, Column = column, Diagonal = IDer - a, ID = fields.Count, Heigth = a });
                fieldColumns[column].Add(fields[fields.Count - 1]);
            }

            if (backWards) amount--;
            else
            {
                amount++;
                IDer++;
            }
        }

        //---> Set Setup Blockades & Player Positions
        for (int i = 0; i < setupBlockades.Count; i++)
        {
            fields[setupBlockades[i]].FieldState = Field.State.Blocked;
        }
        playerTeams.Add(new List<Player>());
        playerTeams.Add(new List<Player>());
        players.Add(new Player() { Null = true });
        playerSpawns.Add(-1);
        for (int i = 0; i < playerTeam1Spawns.Count; i++)
        {
            Player p = new Player() { Team = 0, PosFieldID = playerTeam1Spawns[i], Lives = playerLives1Setups[i], Null = false, ID = i + 1 };
            players.Add(p);
            playerTeams[0].Add(players[players.Count - 1]);
            fields[playerTeam1Spawns[i]].FieldState = Field.State.BluePlayer;
            fields[playerTeam1Spawns[i]].PlayerID = players.Count - 1;
            playerSpawns.Add(playerTeam1Spawns[i]);
        }
        for (int i = 0; i < playerTeam2Spawns.Count; i++)
        {
            Player p = new Player() { Team = 1, PosFieldID = playerTeam2Spawns[i], Lives = playerLives2Setups[i], Null = false, ID = playerTeam1Spawns.Count + i + 1 };
            players.Add(p);
            playerTeams[1].Add(players[players.Count - 1]);
            fields[playerTeam2Spawns[i]].FieldState = Field.State.GreenPlayer;
            fields[playerTeam2Spawns[i]].PlayerID = players.Count - 1;
            playerSpawns.Add(playerTeam2Spawns[i]);
        }
        playerSpawnCount = playerTeam1Spawns.Count + playerTeam2Spawns.Count + 1;

        //---> Process field enviroments
        for (int f = 0; f < fields.Count; f++)
        {
            if (fields[f].Heigth != 0) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth - 1].ID);
            if (fields[f].Heigth + 1 != fieldColumns[fields[f].Column].Count) fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column][fields[f].Heigth + 1].ID);

            int currentFieldDiagonal = fields[f].Diagonal;
            for (int it = -1; it < 2; it += 2)
            {
                if (fields[f].Column + it == fieldColumns.Count || fields[f].Column + it == -1) continue;

                for (int c1 = 0; c1 < fieldColumns[fields[f].Column + it].Count; c1++)
                    if (fieldColumns[fields[f].Column + it][c1].Diagonal == currentFieldDiagonal || fieldColumns[fields[f].Column + it][c1].Diagonal == currentFieldDiagonal + it)
                        fields[f].soroundedTiles.Add(fieldColumns[fields[f].Column + it][c1].ID);
            }
        }

        //---> Card Options (Sorting)
        playedCards.Add(new List<Card>());
        playedCards.Add(new List<Card>());

        for (int i = 0; i < 2; i++)
        {
            cardOptionsTurn1.Add(new List<List<int>>());
            cardOptions.Add(new List<List<int>>());
            for (int t = 0; t < 3; t++)
            {
                cardOptionsTurn1[i].Add(new List<int>());
                cardOptions[i].Add(new List<int>());
            }
            for (int c = 0; c < cards.Count; c++)
            {
                cardOptionsTurn1[i][cards[c].TypeID].Add(cards[c].CardID);
                cardOptions[i][cards[c].TypeID].Add(cards[c].CardID);
            }
        }
    }

    #endregion

    #region VISUALS

    /// <summary>
    /// Visualizes a board position by drawing it specifically in the Console.
    /// </summary>
    private void DrawBoard()
    {
        Console_Write("         {ROUND - " + round + "} ", ConsoleColor.DarkGreen);
        Console_Write(" {Turn - " + turn + "}", ConsoleColor.DarkGreen);
        for (int h = 0; h < heigth; h++)
        {
            for (int w = 0; w < width; w++)
            {
                int tempField = GetFieldByPosition(w, h);

                if (tempField == -1)
                {
                    Console.Write("  ");
                    continue;
                }

                if (fields[tempField].FieldState == Field.State.Normal) Console_Write("■■", ConsoleColor.White);
                else if (fields[tempField].FieldState == Field.State.Blocked) Console_Write("##", ConsoleColor.Magenta);
                else if (fields[tempField].FieldState == Field.State.BluePlayer) Console_Write("()", ConsoleColor.Blue);
                else if (fields[tempField].FieldState == Field.State.GreenPlayer) Console_Write("()", ConsoleColor.Green);
            }
            Console.WriteLine();
        }
    }

    #endregion

    #region UTILITY

    /// <summary>
    /// Writes a text to the console in a specific color
    /// </summary>
    /// <param name="s">The text content</param>
    /// <param name="cc">The text color</param>
    private void Console_Write(string s, ConsoleColor cc)
    {
        Console.ForegroundColor = cc;
        Console.Write(s);
        Console.ResetColor();
    }

    /// <summary>
    /// Tries to find a field out of the fields-array with a specific visual position. Returns the fields-index or -1 if the position doesn't exist.
    /// </summary>
    /// <param name="x">The X-Position</param>
    /// <param name="y">The Y-Position</param>
    /// <returns></returns>
    private int GetFieldByPosition(int x, int y)
    {
        for (int i = 0; i < fields.Count; i++)
            if (fields[i].Pos.x == x && fields[i].Pos.y == y)
                return i;
        return -1;
    }


    /// <summary>
    /// Gives both players all card options back (2x Lists from 0-11)
    /// </summary>
    private void ClearAPMCSOptions()
    {
        APMCS_Options.Clear();
        APMCS_Options.Add(new List<int>(larr));
        APMCS_Options.Add(new List<int>(larr));
    }

    #endregion
}

#region DATA CLASSES

public class Card
{
    public string Name = "";
    public int CardID, TypeID;
}

public class Player
{
    public int PosFieldID, Lives, Team, ID;
    public bool Null = true;
}

public class Field
{
    public Position Pos;
    public State FieldState;
    public int Column, Diagonal, Heigth, ID, PlayerID;
    public List<int> soroundedTiles = new List<int>(), tempTiles = new List<int>();
    public enum State { Normal, Blocked, BluePlayer, GreenPlayer }

    public struct Position
    {
        public int x, y;
    }
}

#endregion
